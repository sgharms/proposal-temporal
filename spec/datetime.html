<!doctype html>
<meta charset="utf8">

<emu-clause id="sec-temporal-datetime">
  <h1>Temporal.DateTime Objects</h1>
  <p>A Temporal.DateTime object is an immutable Object that contains Number values corresponding to a particular year, month, day, hour, minute, second, millisecond, microsecond, and nanosecond.</p>

  <emu-clause id="sec-temporal-datetime-constructor">
    <h1>The Temporal.DateTime Constructor</h1>
    <p>
      The Temporal.DateTime constructor is the %Temporal.DateTime% intrinsic object.
      When called as a constructor, it creates and initializes a new Temporal.DateTime object.
    </p>
    <p>
      The Temporal.DateTime constructor is designed to be subclassable.
      It may be used as the value of an extends clause of a class definition.
      Subclass constructors that intend to inherit the specified DateTime behaviour must include a super call to the %Temporal.DateTime% constructor to create and initialize subclass instances with the necessary internal slots.
    </p>

    <emu-clause id="sec-temporal.datetime">
      <h1>Temporal.DateTime ( _year_, _month_, _day_ [ , _hour_ [ , _minute_ [ , _second_ [ , _millisecond_ [ , _microsecond_ [ , _nanosecond_ ] ] ] ] ] ] )</h1>
      <p>
        When the `Temporal.DateTime` function is called, the following steps are taken:
      </p>
      <emu-note>The value of ? ToInteger(*undefined*) is 0.</emu-note>
      <emu-alg>
        1. If NewTarget is *undefined*, then
          1. Throw a *TypeError* exception.
        1. Let _year_ be ? ToInteger(_year_).
        1. Let _month_ be ? ToInteger(_month_).
        1. Let _day_ be ? ToInteger(_day_).
        1. Let _hour_ be ? ToInteger(_hour_).
        1. Let _minute_ be ? ToInteger(_minute_).
        1. Let _second_ be ? ToInteger(_second_).
        1. Let _millisecond_ be ? ToInteger(_millisecond_).
        1. Let _microsecond_ be ? ToInteger(_microsecond_).
        1. Let _nanosecond_ be ? ToInteger(_nanosecond_).
        1. Return ? CreateTemporalDateTime(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, NewTarget).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-datetime-constructor">
    <h1>Properties of the Temporal.DateTime Constructor</h1>
    <p>The value of the [[Prototype]] internal slot of the Temporal.DateTime constructor is the intrinsic object %FunctionPrototype%.</p>
    <p>The Temporal.DateTime constructor has the following properties:</p>

    <emu-clause id="sec-temporal-datetime-prototype">
      <h1>Temporal.DateTime.prototype</h1>
      <p>The initial value of Temporal.DateTime.prototype is %Temporal.DateTime.prototype%.</p>
      <p>This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.</p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime-@@species">
      <h1>get Temporal.DateTime [ @@species ]</h1>
      <p>
        `Temporal.DateTime[@@species]` is an accessor property whose set accessor function is *undefined*.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Return the *this* value.
      </emu-alg>

      <p>The value of the *"name"* property of this function is *"get [Symbol.species]"*.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.from">
      <h1>Temporal.DateTime.from ( _item_ [ , _options_ ] )</h1>
      <p>
        The `from` method takes two arguments, _item_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _disambiguation_ be ? ToTemporalDisambiguation(_options_).
        1. If Type(_item_) is Object, then
          1. Let _result_ be ? ToTemporalDateTimeRecord(_item_).
        1. Else,
          1. Let _string_ be ? ToString(_item_).
          1. Let _result_ be ? ParseTemporalDateTimeString(_string_).
        1. Let _constructor_ be the *this* value.
        1. Set _result_ to ? RegulateDateTime(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]], _disambiguation_).
        1. Return ? CreateTemporalDateTimeFromStatic(_constructor_, _result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.compare">
      <h1>Temporal.DateTime.compare ( _one_, _two_ )</h1>
      <p>
        The `compare` method takes two arguments, _one_ and _two_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Perform ? RequireInternalSlot(_one_, [[InitializedTemporalDateTime]]).
        1. Perform ? RequireInternalSlot(_two_, [[InitializedTemporalDateTime]]).
        1. Return ! CompareTemporalDateTime(_one_, _two_).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-properties-of-the-temporal-datetime-prototype-object">
    <h1>Properties of the Temporal.DateTime Prototype Object</h1>

    <p>The Temporal.DateTime prototype object</p>
    <ul>
      <li>is the intrinsic object %Temporal.DateTime.prototype%.
      <li>is itself an ordinary object.
      <li>is not a Temporal.DateTime instance and does not have a [[InitializedTemporalDateTime]] internal slot.
      <li>has a [[Prototype]] internal slot whose value is %Object.prototype%.
    </ul>

    <emu-clause id="sec-temporal.datetime.prototype.constructor">
      <h1>Temporal.DateTime.prototype.constructor</h1>
      <p>The initial value of Temporal.DateTime.prototype.constructor is %Temporal.DateTime%.</p>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype-@@tostringtag">
      <h1>Temporal.DateTime.prototype[ @@toStringTag ]</h1>
      <p>
        The initial value of the @@toStringTag property is the string value `"Temporal.DateTime"`.
      </p>
      <p>
        This property has the attributes { [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.
      </p>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.year">
      <h1>get Temporal.DateTime.prototype.year</h1>
      <p>
        `Temporal.DateTime.prototype.year` is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return _dateTime_.[[Year]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.month">
      <h1>get Temporal.DateTime.prototype.month</h1>
      <p>
        `Temporal.DateTime.prototype.month` is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return _dateTime_.[[Month]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.day">
      <h1>get Temporal.DateTime.prototype.day</h1>
      <p>
        `Temporal.DateTime.prototype.day` is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return _dateTime_.[[Day]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.hour">
      <h1>get Temporal.DateTime.prototype.hour</h1>
      <p>
        `Temporal.DateTime.prototype.hour` is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return _dateTime_.[[Hour]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.minute">
      <h1>get Temporal.DateTime.prototype.minute</h1>
      <p>
        `Temporal.DateTime.prototype.minute` is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return _dateTime_.[[Minute]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.second">
      <h1>get Temporal.DateTime.prototype.second</h1>
      <p>
        `Temporal.DateTime.prototype.second` is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return _dateTime_.[[Second]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.millisecond">
      <h1>get Temporal.DateTime.prototype.millisecond</h1>
      <p>
        `Temporal.DateTime.prototype.millisecond` is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return _dateTime_.[[Millisecond]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.microsecond">
      <h1>get Temporal.DateTime.prototype.microsecond</h1>
      <p>
        `Temporal.DateTime.prototype.microsecond` is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return _dateTime_.[[Microsecond]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.nanosecond">
      <h1>get Temporal.DateTime.prototype.nanosecond</h1>
      <p>
        `Temporal.DateTime.prototype.nanosecond` is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return _dateTime_.[[Nanosecond]].
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.dayofweek">
      <h1>get Temporal.DateTime.prototype.dayOfWeek</h1>
      <p>
        `Temporal.DateTime.prototype.dayOfWeek` is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ! ToDayOfWeek(_dateTime_.[[Year]], _dateTime_.[[Month]], _dateTime_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.dayofyear">
      <h1>get Temporal.DateTime.prototype.dayOfYear</h1>
      <p>
        `Temporal.DateTime.prototype.dayOfYear` is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ! ToDayOfYear(_dateTime_.[[Year]], _dateTime_.[[Month]], _dateTime_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.weekofyear">
      <h1>get Temporal.DateTime.prototype.weekOfYear</h1>
      <p>
        `Temporal.DateTime.prototype.weekOfYear` is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ! ToWeekOfYear(_dateTime_.[[Year]], _dateTime_.[[Month]], _dateTime_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.daysinyear">
      <h1>get Temporal.DateTime.prototype.daysInYear</h1>
      <p>
        `Temporal.DateTime.prototype.daysInYear` is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ! DaysInYear(_dateTime_.[[Year]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.daysinmonth">
      <h1>get Temporal.DateTime.prototype.daysInMonth</h1>
      <p>
        `Temporal.DateTime.prototype.daysInMonth` is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ! DaysInMonth(_dateTime_.[[Year]], _dateTime_.[[Month]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-get-temporal.datetime.prototype.isleapyear">
      <h1>get Temporal.DateTime.prototype.isLeapYear</h1>
      <p>
        `Temporal.DateTime.prototype.isLeapYear` is an accessor property whose set accessor function is undefined.
        Its get accessor function performs the following steps:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ! IsLeapYear(_dateTime_.[[Year]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.with">
      <h1>Temporal.DateTime.prototype.with ( _temporalDateTimeLike_ [ , _options_ ] )</h1>
      <p>
        The `with` method takes two arguments, _temporalDateTimeLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _partialDateTime_ be ? ToPartialDateTime(_temporalDateTimeLike_).
        1. Let _disambiguation_ be ? ToTemporalDisambiguation(_options_).
        1. If _partialDateTime_.[[Year]] is not *undefined*, then
          1. Let _year_ be _partialDateTime_.[[Year]].
        1. Else
          1. Let _year_ be _dateTime_.[[Year]].
        1. If _partialDateTime_.[[Month]] is not *undefined*, then
          1. Let _month_ be _partialDateTime_.[[Month]].
        1. Else
          1. Let _month_ be _dateTime_.[[Month]].
        1. If _partialDateTime_.[[Day]] is not *undefined*, then
          1. Let _day_ be _partialDateTime_.[[Day]].
        1. Else
          1. Let _day_ be _dateTime_.[[Day]].
        1. If _partialDateTime_.[[Hour]] is not *undefined*, then
          1. Let _hour_ be _partialDateTime_.[[Hour]].
        1. Else
          1. Let _hour_ be _dateTime_.[[Hour]].
        1. If _partialDateTime_.[[Minute]] is not *undefined*, then
          1. Let _minute_ be _partialDateTime_.[[Minute]].
        1. Else
          1. Let _minute_ be _dateTime_.[[Minute]].
        1. If _partialDateTime_.[[Second]] is not *undefined*, then
          1. Let _second_ be _partialDateTime_.[[Second]].
        1. Else
          1. Let _second_ be _dateTime_.[[Second]].
        1. If _partialDateTime_.[[Millisecond]] is not *undefined*, then
          1. Let _millisecond_ be _partialDateTime_.[[Millisecond]].
        1. Else
          1. Let _millisecond_ be _dateTime_.[[Millisecond]].
        1. If _partialDateTime_.[[Microsecond]] is not *undefined*, then
          1. Let _microsecond_ be _partialDateTime_.[[Microsecond]].
        1. Else
          1. Let _microsecond_ be _dateTime_.[[Microsecond]].
        1. If _partialDateTime_.[[Nanosecond]] is not *undefined*, then
          1. Let _nanosecond_ be _partialDateTime_.[[Nanosecond]].
        1. Else
          1. Let _nanosecond_ be _dateTime_.[[Nanosecond]].
        1. Let _result_ be ? RegulateDateTime(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _disambiguation_).
        1. Assert: ! ValidateDateTime(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]) is *true*.
        1. Return ? CreateTemporalDateTimeFromInstance(_dateTime_, _result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.plus">
      <h1>Temporal.DateTime.prototype.plus ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        The `plus` method takes two arguments, _temporalDurationLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _duration_ be ? ToLimitedTemporalDuration(_temporalDurationLike_, « »).
        1. Let _disambiguation_ be ? ToArithmeticTemporalDisambiguation(_options_).
        1. Let _timePart_ be ? AddTime(_dateTime_.[[Hour]], _dateTime_.[[Minute]], _dateTime_.[[Second]], _dateTime_.[[Millisecond]], _dateTime_.[[Microsecond]], _dateTime_.[[Nanosecond]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. Let _datePart_ be ? AddDate(_dateTime_.[[Year]], _dateTime_.[[Month]], _dateTime_.[[Day]], _duration_.[[Years]], _duration_.[[Months]], _duration_.[[Days]], _disambiguation_).
        1. Let _datePart_ be ? BalanceDate(_datePart_.[[Year]], _datePart_.[[Month]], _datePart_.[[Day]] + _timePart_.[[Day]]).
        1. Let _result_ be ? RegulateDateTime(_datePart_.[[Year]], _datePart_.[[Month]], _datePart_.[[Day]], _timePart_.[[Hour]], _timePart_.[[Minute]], _timePart_.[[Second]], _timePart_.[[Millisecond]], _timePart_.[[Microsecond]], _timePart_.[[Nanosecond]], _disambiguation_).
        1. Assert: ! ValidateDateTime(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]) is *true*.
        1. Return ? CreateTemporalDateTimeFromInstance(_dateTime_, _result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.minus">
      <h1>Temporal.DateTime.prototype.minus ( _temporalDurationLike_ [ , _options_ ] )</h1>
      <p>
        The `minus` method takes two arguments, _temporalDurationLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Let _duration_ be ? ToLimitedTemporalDuration(_temporalDurationLike_, « »).
        1. Let _disambiguation_ be ? ToArithmeticTemporalDisambiguation(_options_).
        1. Let _timePart_ be ? SubtractTime(_dateTime_.[[Hour]], _dateTime_.[[Minute]], _dateTime_.[[Second]], _dateTime_.[[Millisecond]], _dateTime_.[[Microsecond]], _dateTime_.[[Nanosecond]], _duration_.[[Hours]], _duration_.[[Minutes]], _duration_.[[Seconds]], _duration_.[[Milliseconds]], _duration_.[[Microseconds]], _duration_.[[Nanoseconds]]).
        1. Let _datePart_ be ? SubtractDate(_dateTime_.[[Year]], _dateTime_.[[Month]], _dateTime_.[[Day]], _duration_.[[Years]], _duration_.[[Months]], _duration_.[[Days]] - _timePart_.[[Day]], _disambiguation_).
        1. Let _result_ be ? RegulateDateTime(_datePart_.[[Year]], _datePart_.[[Month]], _datePart_.[[Day]], _timePart_.[[Hour]], _timePart_.[[Minute]], _timePart_.[[Second]], _timePart_.[[Millisecond]], _timePart_.[[Microsecond]], _timePart_.[[Nanosecond]], _disambiguation_).
        1. Assert: ! ValidateDateTime(_result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]) is *true*.
        1. Return ? CreateTemporalDateTimeFromInstance(_dateTime_, _result_.[[Year]], _result_.[[Month]], _result_.[[Day]], _result_.[[Hour]], _result_.[[Minute]], _result_.[[Second]], _result_.[[Millisecond]], _result_.[[Microsecond]], _result_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.difference">
      <h1>Temporal.DateTime.prototype.difference ( _other_ [ , _options_ ] )</h1>
      <p>
        The `difference` method takes two arguments, _other_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Perform ? RequireInternalSlot(_other_, [[InitializedTemporalDateTime]]).
        1. Let _largestUnit_ be ? ToLargestTemporalUnit(_options_, « », *"days"*).
        1. If ! CompareTemporalDateTime(_dateTime_, _other_) &lt; 0, then
          1. Let _greater_ be _other_.
          1. Let _smaller_ be _dateTime_.
        1. Else,
          1. Let _greater_ be _dateTime_.
          1. Let _smaller_ be _other_.
        1. Let _timeDifference_ be ! DifferenceTime(_smaller_, _greater_).
        1. Let _balanceResult_ be ? BalanceDate(_greater_.[[Year]], _greater_.[[Month]], _greater_.[[Day]] + _timeDifference_.[[Days]]).
        1. Let _dateDifference_ be ! DifferenceDate(_smaller_, _balanceResult_, _largestUnit_).
        1. Let _days_ be _dateDifference_.[[Days]].
        1. Let _hours_ be _timeDifference_.[[Hour]].
        1. Let _minutes_ be _timeDifference_.[[Minute]].
        1. Let _seconds_ be _timeDifference_.[[Second]].
        1. If _largestUnit_ is `"hours"`, `"minutes"`, or `"seconds"`, then
          1. Set _hours_ to _hours_ + 24 &times; _days_.
          1. Set _days_ to 0.
        1. If _largestUnit_ is `"minutes"` or `"seconds"`, then
          1. Set _minutes_ to _minutes_ + 60 &times; _hours_.
          1. Set _hours_ to 0.
        1. If _largestUnit_ is `"seconds"`, then
          1. Set _seconds_ to _seconds_ + 60 &times; _minutes_.
          1. Set _minutes_ to 0.
        1. Return ? CreateTemporalDuration(_dateDifference_.[[Years]], _dateDifference_.[[Months]], _days_, _hours_, _minutes_, _seconds_, _timeDifference_.[[Millisecond]], _timeDifference_.[[Microsecond]], _timeDifference_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.tostring">
      <h1>Temporal.DateTime.prototype.toString ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ! TemporalDateTimeToString(_dateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.tolocalestring">
      <h1>Temporal.DateTime.prototype.toLocaleString ( [ _locales_ [ , _options_ ] ] )</h1>
      <p>
        The `toLocaleString` method takes two arguments, _locales_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. If the implementation does not include the ECMA-402 Internationalization API, then
          1. Return ! TemporalDateTimeToString(_dateTime_).
        1. Let _dateFormat_ be ? Construct(%DateTimeFormat%, « _locales_, _options_ »).
        1. Return ? FormatDateTime(_dateFormat_, _dateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.tojson">
      <h1>Temporal.DateTime.prototype.toJSON ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ! TemporalDateTimeToString(_dateTime_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.intimezone">
      <h1>Temporal.DateTime.prototype.inTimeZone ( [ _temporalTimeZoneLike_ [ , _options_ ] ] )</h1>
      <p>
        The `inTimeZone` method takes two arguments, _temporalTimeZoneLike_ and _options_.
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. If _temporalTimeZoneLike_ is *undefined*, then
          1. Set _temporalTimeZoneLike_ to *"UTC"*.
        1. Let _timeZone_ be ? ToTemporalTimeZone(_temporalTimeZoneLike_).
        1. Let _disambiguation_ be ? ToTimeZoneTemporalDisambiguation(_options_).
        1. Return ? GetAbsoluteFor(_timeZone_, _dateTime_, _disambiguation_).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.getdate">
      <h1>Temporal.DateTime.prototype.getDate ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ? CreateTemporalDate(_dateTime_.[[Year]], _dateTime_.[[Month]], _dateTime_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.getyearmonth">
      <h1>Temporal.DateTime.prototype.getYearMonth ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ? CreateTemporalYearMonth(_dateTime_.[[Year]], _dateTime_.[[Month]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.getmonthday">
      <h1>Temporal.DateTime.prototype.getMonthDay ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ? CreateTemporalMonthDay(_dateTime_.[[Month]], _dateTime_.[[Day]]).
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal.datetime.prototype.gettime">
      <h1>Temporal.DateTime.prototype.getTime ( )</h1>
      <p>
        The following steps are taken:
      </p>
      <emu-alg>
        1. Let _dateTime_ be the *this* value.
        1. Perform ? RequireInternalSlot(_dateTime_, [[InitializedTemporalDateTime]]).
        1. Return ? CreateTemporalTime(_dateTime_.[[Hour]], _dateTime_.[[Minute]], _dateTime_.[[Second]], _dateTime_.[[Millisecond]], _dateTime_.[[Microsecond]], _dateTime_.[[Nanosecond]]).
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-temporal-datetime-abstract-ops">
    <h1>Abstract operations</h1>

    <emu-clause id="sec-temporal-getepochfromparts" aoid="GetEpochFromParts">
      <h1>GetEpochFromParts ( _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, and _nanosecond_ are integer Number values.
        1. Assert: _month_ ≥ 1 and _month_ ≤ 12.
        1. Assert: _day_ ≥ 1 and _day_ ≤ ! DaysInMonth(_year_, _month_).
        1. Assert: ! ValidateTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *true*.
        1. Let _date_ be ! MakeDay(_year_, _month_, _day_).
        1. Let _time_ be ! MakeTime(_hour_, _minute_, _second_, _millisecond_).
        1. Let _ms_ be ! MakeDate(_date_, _time_).
        1. Assert: _ms_ is finite.
        1. Return _ms_ × 1,000,000 + _microsecond_ × 1,000 + _nanosecond_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-datetimewithinlimits" aoid="DateTimeWithinLimits">
      <h1>DateTimeWithinLimits ( _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ )</h1>
      <emu-note>
        <p>
          Temporal.DateTime objects can represent points in time within 24 hours (8.64 × 10<sup>16</sup> nanoseconds) of the Temporal.Absolute boundaries
          This ensures that a Temporal.Absolute object can be converted into a Temporal.DateTime object using any time zone.
        </p>
      </emu-note>
      <emu-alg>
        1. Let _ns_ be ! GetEpochFromParts(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
        1. If _ns_ ≤ -8.64 × 10<sup>21</sup><sub>ℝ</sub> - 8.64 × 10<sup>16</sup><sub>ℝ</sub>, then
          1. Return ~too early~.
        1. If _ns_ ≥ 8.64 × 10<sup>21</sup><sub>ℝ</sub> + 8.64 × 10<sup>16</sup><sub>ℝ</sub>, then
          1. Return ~too late~.
        1. Return ~in range~.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-topartialdatetime" aoid="ToPartialDateTime">
      <h1>ToPartialDateTime ( _temporalDateTimeLike_ )</h1>
      <emu-alg>
        1. If Type(_temporalDateTimeLike_) is not Object, then
          1. Throw a *TypeError* exception.
        1. Let _result_ be the new Record {
            [[Year]]: *undefined*,
            [[Month]]: *undefined*,
            [[Day]]: *undefined*,
            [[Hour]]: *undefined*,
            [[Minute]]: *undefined*,
            [[Second]]: *undefined*,
            [[Millisecond]]: *undefined*,
            [[Microsecond]]: *undefined*,
            [[Nanosecond]]: *undefined*
          }.
        1. Let _any_ be *false*.
        1. For each row of <emu-xref href="#table-temporal-temporaldatetimelike-properties"></emu-xref>, except the header row, in table order, do
          1. Let _property_ be the Property value of the current row.
          1. Let _value_ be ? Get(_temporalDateTimeLike_, _property_).
          1. If _value_ is not *undefined*, then
            1. Set _any_ to *true*.
            1. Set _value_ to ? ToInteger(_value_).
            1. Set _result_'s internal slot whose name is the Internal Slot value of the current row to _value_.
        1. If _any_ is *false*, then
          1. Throw a *TypeError* exception.
        1. Return _result_.
      </emu-alg>

      <emu-table id="table-temporal-temporaldatetimelike-properties">
        <emu-caption>Internal slots and properties for Temporal.DateTime argument objects</emu-caption>
        <table class="real-table">
          <thead>
            <tr>
              <th>Internal Slot</th>
              <th>Property</th>
              <th>Optional</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>[[Day]]</td>
              <td>`"day"`</td>
              <td>*false*</td>
            </tr>

            <tr>
              <td>[[Hour]]</td>
              <td>`"hour"`</td>
              <td>*true*</td>
            </tr>

            <tr>
              <td>[[Microsecond]]</td>
              <td>`"microsecond"`</td>
              <td>*true*</td>
            </tr>

            <tr>
              <td>[[Millisecond]]</td>
              <td>`"millisecond"`</td>
              <td>*true*</td>
            </tr>

            <tr>
              <td>[[Minute]]</td>
              <td>`"minute"`</td>
              <td>*true*</td>
            </tr>

            <tr>
              <td>[[Month]]</td>
              <td>`"month"`</td>
              <td>*false*</td>
            </tr>

            <tr>
              <td>[[Nanosecond]]</td>
              <td>`"nanosecond"`</td>
              <td>*true*</td>
            </tr>

            <tr>
              <td>[[Second]]</td>
              <td>`"second"`</td>
              <td>*true*</td>
            </tr>

            <tr>
              <td>[[Year]]</td>
              <td>`"year"`</td>
              <td>*false*</td>
            </tr>
          </tbody>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-temporal-regulatedatetime" aoid="RegulateDateTime">
      <h1>RegulateDateTime ( _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_, _disambiguation_ )</h1>
      <emu-alg>
        1. Assert: _disambiguation_ is one of `"constrain"`, `"balance"`, or `"reject"`.
        1. If _disambiguation_ is `"constrain"`, then
          1. Return ! ConstrainDateTime(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
        1. If _disambiguation_ is `"balance"`, then
          1. Let _balancedTime_ be ? BalanceTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
          1. Let _balancedDate_ be ? BalanceDate(_year_, _month_, _day_ + _balancedTime_.[[Days]]).
          1. If ! ValidateDateTime(_balancedDate_.[[Year]], _balancedDate_.[[Month]], _balancedDate_.[[Day]],
              _balancedTime_.[[Hour]], _balancedTime_.[[Minute]], _balancedTime_.[[Second]],
              _balancedTime_.[[Millisecond]], _balancedTime_.[[Microsecond]], _balancedTime_.[[Nanosecond]]) is *false*, then
            1. Throw a *RangeError* exception.
          1. Return the Record {
            [[Year]]: _balancedDate_.[[Year]],
            [[Month]]: _balancedDate_.[[Month]],
            [[Day]]: _balancedDate_.[[Day]],
            [[Hour]]: _balancedTime_.[[Hour]],
            [[Minute]]: _balancedTime_.[[Minute]],
            [[Second]]: _balancedTime_.[[Second]],
            [[Millisecond]]: _balancedTime_.[[Millisecond]],
            [[Microsecond]]: _balancedTime_.[[Microsecond]],
            [[Nanosecond]]: _balancedTime_.[[Nanosecond]]
            }.
        1. If _disambiguation_ is `"reject"`, then
          1. If ! ValidateDateTime(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *false*, then
            1. Throw a *RangeError* exception.
          1. Return the Record {
            [[Year]]: _year_,
            [[Month]]: _month_,
            [[Day]]: _day_,
            [[Hour]]: _hour_,
            [[Minute]]: _minute_,
            [[Second]]: _second_,
            [[Millisecond]]: _millisecond_,
            [[Microsecond]]: _microsecond_,
            [[Nanosecond]]: _nanosecond_
            }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-validatedatetime" aoid="ValidateDateTime">
      <h1>ValidateDateTime ( _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, and _nanosecond_ are integer Number values.
        1. If _year_ &lt; &minus;271821 or _year_ &gt; 275760, then
          1. Return *false*.
        1. If _month_ &lt; 1 or _month_ &gt; 12, then
          1. Return *false*.
        1. Let _maxDay_ be ! DaysInMonth(_year_, _month_).
        1. If _day_ &lt; 1 or _day_ &gt; _maxDay_, then
          1. Return *false*.
        1. If ! ValidateTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *false*, then
          1. Return *false*.
        1. Let _withinLimits_ be ! DateTimeWithinLimits(_year_, _month_, _day_,
            _hour_, _minute_, _second_,
            _millisecond_, _microsecond_, _nanosecond_).
        1. If _withinLimits_ is not ~in range~, then
          1. Return *false*.
        1. Return *true*.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-constraindatetime" aoid="ConstrainDateTime">
      <h1>ConstrainDateTime ( _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ )</h1>
      <emu-alg>
        1. Assert: _year_, _month_, and _day_ are integer Number values.
        1. Set _year_ to ! ConstrainToRange(_year_, -271821, 275760).
        1. Set _month_ to ! ConstrainToRange(_month_, 1, 12).
        1. Set _day_ to ! ConstrainToRange(_day_, 1, ! DaysInMonth(_year_, _month_)).
        1. Let _constrainedTime_ be ! ConstrainTime(_hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).
        1. Let _withinLimits_ be ! DateTimeWithinLimits(_year_, _month_, _day_,
            _constrainedTime_.[[Hour]], _constrainedTime_.[[Minute]], _constrainedTime_.[[Second]],
            _constrainedTime_.[[Millisecond]], _constrainedTime_.[[Microsecond]], _constrainedTime_.[[Nanosecond]]).
        1. If _withinLimits_ is ~too early~, then
          1. Return the Record {
              [[Year]]: -271821,
              [[Month]]: 4,
              [[Day]]: 19,
              [[Hour]]: 0,
              [[Minute]]: 0,
              [[Second]]: 0,
              [[Millisecond]]: 0,
              [[Microsecond]]: 0,
              [[Nanosecond]]: 1
            }.
        1. If _withinLimits_ is ~too late~, then
          1. Return the Record {
              [[Year]]: 271821,
              [[Month]]: 9,
              [[Day]]: 13,
              [[Hour]]: 23,
              [[Minute]]: 59,
              [[Second]]: 59,
              [[Millisecond]]: 999,
              [[Microsecond]]: 999,
              [[Nanosecond]]: 999
            }.
        1. Return the Record {
            [[Year]]: _year_,
            [[Month]]: _month_,
            [[Day]]: _day_,
            [[Hour]]: _constrainedTime_.[[Hour]],
            [[Minute]]: _constrainedTime_.[[Minute]],
            [[Second]]: _constrainedTime_.[[Second]],
            [[Millisecond]]: _constrainedTime_.[[Millisecond]],
            [[Microsecond]]: _constrainedTime_.[[Microsecond]],
            [[Nanosecond]]: _constrainedTime_.[[Nanosecond]]
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaldatetime" aoid="CreateTemporalDateTime">
      <h1>CreateTemporalDateTime ( _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ [, _newTarget_] )</h1>
      <emu-alg>
        1. If ! ValidateDateTime(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *false*, then
          1. Throw a *RangeError* exception.
        1. If _newTarget_ is not given, set it to %Temporal.DateTime%.
        1. Let _object_ be ? OrdinaryCreateFromConstructor(_newTarget_, `"%Temporal.DateTime.prototype%"`, « [[InitializedTemporalDateTime]], [[Year]], [[Month]], [[Day]], [[Hour]], [[Minute]], [[Second]], [[Millisecond]], [[Microsecond]], [[Nanosecond]] »).
        1. Set _object_.[[Year]] to _year_.
        1. Set _object_.[[Month]] to _month_.
        1. Set _object_.[[Day]] to _day_.
        1. Set _object_.[[Hour]] to _hour_.
        1. Set _object_.[[Minute]] to _minute_.
        1. Set _object_.[[Second]] to _second_.
        1. Set _object_.[[Millisecond]] to _millisecond_.
        1. Set _object_.[[Microsecond]] to _microsecond_.
        1. Set _object_.[[Nanosecond]] to _nanosecond_.
        1. Return _object_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaldatetimefrominstance" aoid="CreateTemporalDateTimeFromInstance">
      <h1>CreateTemporalDateTimeFromInstance ( _dateTime_, _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ )</h1>
      <emu-alg>
        1. Assert: Type(_dateTime_) is Object and _dateTime_ has an [[InitializedTemporalDateTime]] internal slot.
        1. Assert: ! ValidateDateTime(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *true*.
        1. Let _constructor_ be ? SpeciesConstructor(_dateTime_, %Temporal.DateTime%).
        1. Let _result_ be ? Construct(_constructor_, « _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ »).
        1. Perform ? RequireInternalSlot(_result_, [[InitializedTemporalDateTime]]).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-createtemporaldatetimefromstatic" aoid="CreateTemporalDateTimeFromStatic">
      <h1>CreateTemporalDateTimeFromStatic ( _constructor_, _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ )</h1>
      <emu-alg>
        1. Assert: ! ValidateDateTime(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_) is *true*.
        1. If ! IsConstructor(_constructor_) is *false*, then
          1. Throw a *TypeError* exception.
        1. Let _result_ be ? Construct(_constructor_, « _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ »).
        1. Perform ? RequireInternalSlot(_result_, [[InitializedTemporalDateTime]]).
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-parsetemporaldatetimestring" aoid="ParseTemporalDateTimeString">
      <h1>ParseTemporalDateTimeString ( _isoString_ )</h1>
      <emu-alg>
        1. Assert: Type(_isoString_) is String.
        1. Let _valid_ be *true* if _isoString_ matches <a href="https://github.com/tc39/proposal-temporal/blob/main/polyfill/lib/regex.mjs">the "datetime" regular expression in the polyfill</a> and *false* otherwise.
        1. <mark>TODO: Actually specify this somehow.</mark>
        1. If _valid_ is *false*, then
          1. Throw a *RangeError* exception.
        1. Let _year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_ be the respective parts of _isoString_ interpreted as decimal numbers.
        1. Return the new Record {
            [[Year]]: _year_,
            [[Month]]: _month_,
            [[Day]]: _day_,
            [[Hour]]: _hour_,
            [[Minute]]: _minute_,
            [[Second]]: _second_,
            [[Millisecond]]: _millisecond_,
            [[Microsecond]]: _microsecond_,
            [[Nanosecond]]: _nanosecond_
          }.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-totemporaldatetimerecord" aoid="ToTemporalDateTimeRecord">
      <h1>ToTemporalDateTimeRecord ( _temporalDateTimeLike_ )</h1>
      <emu-note>The value of ? ToInteger(*undefined*) is 0.</emu-note>
      <emu-alg>
        1. Assert: Type(_temporalDateTimeLike_) is Object.
        1. If _temporalDateTimeLike_ has an [[InitializedTemporalDateTime]] internal slot, then
          1. Return the Record {
              [[Year]]: _temporalDateTimeLike_.[[Year]],
              [[Month]]: _temporalDateTimeLike_.[[Month]],
              [[Day]]: _temporalDateTimeLike_.[[Day]],
              [[Hour]]: _temporalDateTimeLike_.[[Hour]],
              [[Minute]]: _temporalDateTimeLike_.[[Minute]],
              [[Second]]: _temporalDateTimeLike_.[[Second]],
              [[Millisecond]]: _temporalDateTimeLike_.[[Millisecond]],
              [[Microsecond]]: _temporalDateTimeLike_.[[Microsecond]],
              [[Nanosecond]]: _temporalDateTimeLike_.[[Nanosecond]]
            }.
        1. Let _result_ be a new Record with all the internal slots given in the Internal Slot column in <emu-xref href="#table-temporal-temporaldatetimelike-properties"></emu-xref>.
        1. For each row of <emu-xref href="#table-temporal-temporaldatetimelike-properties"></emu-xref>, except the header row, in table order, do
          1. Let _property_ be the Property value of the current row.
          1. Let _value_ be ? Get(_temporalDateTimeLike_, _property_).
          1. If _value_ is *undefined* and the Optional value of the current row is *false*, then
            1. Throw a *TypeError* exception.
          1. Let _value_ be ? ToInteger(_value_).
          1. Set _result_'s internal slot whose name is the Internal Slot value of the current row to _value_.
        1. Return _result_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-temporaldatetimetostring" aoid="TemporalDateTimeToString">
      <h1>TemporalDateTimeToString ( _dateTime_ )</h1>
      <emu-alg>
        1. Assert: Type(_dateTime_) is Object.
        1. Assert: _dateTime_ has an [[InitializedTemporalDateTime]] internal slot.
        1. Let _year_ be ! PadYear(_dateTime_.[[Year]]).
        1. Let _month_ be _dateTime_.[[Month]] formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _day_ be _dateTime_.[[Day]] formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _hour_ be _dateTime_.[[Hour]] formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _minute_ be _dateTime_.[[Minute]] formatted as a two-digit decimal number, padded to the left with a zero if necessary.
        1. Let _seconds_ be ! FormatSecondsStringPart(_dateTime_.[[Second]], _dateTime_.[[Millisecond]], _dateTime_.[[Microsecond]], _dateTime_.[[Nanosecond]]).
        1. Return the string-concatenation of _year_, the code unit 0x002D (HYPHEN-MINUS), _month_, the code unit 0x002D (HYPHEN-MINUS), _day_, 0x0054 (LATIN CAPITAL LETTER T), _hour_, the code unit 0x003A (COLON), _minute_, and _seconds_.
      </emu-alg>
    </emu-clause>

    <emu-clause id="sec-temporal-comparetemporaldatetime" aoid="CompareTemporalDateTime">
      <h1>CompareTemporalDateTime ( _one_, _two_ )</h1>
      <emu-alg>
        1. Assert: Type(_one_) is Object.
        1. Assert: _one_ has an [[InitializedTemporalDateTime]] internal slot.
        1. Assert: Type(_two_) is Object.
        1. Assert: _two_ has an [[InitializedTemporalDateTime]] internal slot.
        1. If _one_.[[Year]] &gt; _two_.[[Year]], return 1.
        1. If _one_.[[Year]] &lt; _two_.[[Year]], return -1.
        1. If _one_.[[Month]] &gt; _two_.[[Month]], return 1.
        1. If _one_.[[Month]] &lt; _two_.[[Month]], return -1.
        1. If _one_.[[Day]] &gt; _two_.[[Day]], return 1.
        1. If _one_.[[Day]] &lt; _two_.[[Day]], return -1.
        1. If _one_.[[Hour]] &gt; _two_.[[Hour]], return 1.
        1. If _one_.[[Hour]] &lt; _two_.[[Hour]], return -1.
        1. If _one_.[[Minute]] &gt; _two_.[[Minute]], return 1.
        1. If _one_.[[Minute]] &lt; _two_.[[Minute]], return -1.
        1. If _one_.[[Second]] &gt; _two_.[[Second]], return 1.
        1. If _one_.[[Second]] &lt; _two_.[[Second]], return -1.
        1. If _one_.[[Millisecond]] &gt; _two_.[[Millisecond]], return 1.
        1. If _one_.[[Millisecond]] &lt; _two_.[[Millisecond]], return -1.
        1. If _one_.[[Microsecond]] &gt; _two_.[[Microsecond]], return 1.
        1. If _one_.[[Microsecond]] &lt; _two_.[[Microsecond]], return -1.
        1. If _one_.[[Nanosecond]] &gt; _two_.[[Nanosecond]], return 1.
        1. If _one_.[[Nanosecond]] &lt; _two_.[[Nanosecond]], return -1.
        1. Return +0.
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
